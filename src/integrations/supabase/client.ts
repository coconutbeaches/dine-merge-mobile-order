// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { SupabaseClient } from '@supabase/supabase-js';
import type { Database } from '@/types/supabaseTypes';

// Use environment variables - no fallbacks for security
const SUPABASE_URL = process.env.NEXT_PUBLIC_SUPABASE_URL?.trim();
const SUPABASE_PUBLISHABLE_KEY = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY?.trim();

// Validate environment variables in development
if (process.env.NODE_ENV === 'development') {
  if (!SUPABASE_URL) {
    console.warn('NEXT_PUBLIC_SUPABASE_URL is not set');
  }
  if (!SUPABASE_PUBLISHABLE_KEY) {
    console.warn('NEXT_PUBLIC_SUPABASE_ANON_KEY is not set');
  }
}

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

// Create a custom storage adapter that migrates from cookies to localStorage
const customStorage = typeof window !== 'undefined' ? {
  getItem: (key: string) => {
    // First try localStorage (new method)
    const localStorageValue = window.localStorage.getItem(key);
    if (localStorageValue) {
      return localStorageValue;
    }
    
    // Fallback to cookies for migration (old method)
    const cookieValue = document.cookie
      .split('; ')
      .find(row => row.startsWith(key + '='))
      ?.split('=')[1];
    
    // If found in cookies, migrate to localStorage
    if (cookieValue) {
      window.localStorage.setItem(key, cookieValue);
      // Clear the cookie after migration
      document.cookie = `${key}=; path=/; expires=Thu, 01 Jan 1970 00:00:00 GMT`;
      return cookieValue;
    }
    
    return null;
  },
  setItem: (key: string, value: string) => {
    // Always use localStorage for new values
    window.localStorage.setItem(key, value);
    // Also clear any existing cookies with the same key
    document.cookie = `${key}=; path=/; expires=Thu, 01 Jan 1970 00:00:00 GMT`;
  },
  removeItem: (key: string) => {
    window.localStorage.removeItem(key);
    // Also clear from cookies
    document.cookie = `${key}=; path=/; expires=Thu, 01 Jan 1970 00:00:00 GMT`;
  },
} : undefined;

let supabaseClient: SupabaseClient<Database> | null = null;
let hasLoggedMissingError = false;

if (SUPABASE_URL && SUPABASE_PUBLISHABLE_KEY) {
  supabaseClient = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY, {
    auth: {
      // Enable automatic session refresh
      autoRefreshToken: true,
      // Persist auth session in localStorage to prevent cookie bloat
      persistSession: true,
      // Detect session in URL (for OAuth flows)
      detectSessionInUrl: true,
      // Storage key for session
      storageKey: 'supabase.auth.token',
      // Use custom storage that migrates from cookies to localStorage
      storage: customStorage,
    },
    realtime: {
      connect: true,
      params: { eventsPerSecond: 10 },
      retryAttempts: 6,
      timeout: 40000
    }
  });
} else if (typeof window !== 'undefined') {
  if (!hasLoggedMissingError) {
    console.error('[supabase] Public Supabase environment variables are missing. Client-side features depending on Supabase will be disabled.');
    hasLoggedMissingError = true;
  }
} else if (!hasLoggedMissingError) {
  console.warn('[supabase] Public Supabase environment variables are missing. Server-side features depending on Supabase will be disabled.');
  hasLoggedMissingError = true;
}

const missingConfigError = () =>
  new Error('Supabase client is not configured. Ensure NEXT_PUBLIC_SUPABASE_URL and NEXT_PUBLIC_SUPABASE_ANON_KEY are set.');

const createUnavailableProxy = (path: string): any => {
  const proxyTarget = () => undefined;
  return new Proxy(proxyTarget, {
    get(_target, prop) {
      if (prop === 'then') {
        return (onFulfilled?: unknown, onRejected?: unknown) =>
          Promise.reject(missingConfigError()).then(onFulfilled as any, onRejected as any);
      }
      if (prop === 'catch') {
        return (onRejected?: unknown) =>
          Promise.reject(missingConfigError()).catch(onRejected as any);
      }
      if (prop === 'finally') {
        return (onFinally?: unknown) =>
          Promise.reject(missingConfigError()).finally(onFinally as any);
      }
      return createUnavailableProxy(`${path}.${String(prop)}`);
    },
    apply(_target, _thisArg, args) {
      if (!hasLoggedMissingError) {
        console.warn(`[supabase] Attempted to call ${path} but the client is not configured.`, args);
        hasLoggedMissingError = true;
      }
      return createUnavailableProxy(`${path}()`);
    },
  });
};

const supabaseProxy = new Proxy({} as SupabaseClient<Database>, {
  get(_target, prop) {
    if (!supabaseClient) {
      return createUnavailableProxy(`supabase.${String(prop)}`);
    }
    const value = Reflect.get(supabaseClient as SupabaseClient<Database>, prop);
    return typeof value === 'function' ? value.bind(supabaseClient) : value;
  },
});

export const supabase = supabaseProxy;

export const hasSupabaseClient = () => Boolean(supabaseClient);
