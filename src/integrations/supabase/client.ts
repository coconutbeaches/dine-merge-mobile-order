// This file is automatically generated. Do not edit it directly.
import { createBrowserClient } from '@supabase/ssr';
import type { SupabaseClient } from '@supabase/supabase-js';
import type { Database } from '@/types/supabaseTypes';

// Use environment variables - no fallbacks for security
const SUPABASE_URL = process.env.NEXT_PUBLIC_SUPABASE_URL?.trim();
const SUPABASE_PUBLISHABLE_KEY = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY?.trim();

// Validate environment variables in development
if (process.env.NODE_ENV === 'development') {
  if (!SUPABASE_URL) {
    console.warn('NEXT_PUBLIC_SUPABASE_URL is not set');
  }
  if (!SUPABASE_PUBLISHABLE_KEY) {
    console.warn('NEXT_PUBLIC_SUPABASE_ANON_KEY is not set');
  }
}

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

let supabaseClient: SupabaseClient<Database> | null = null;
let hasLoggedMissingError = false;

if (SUPABASE_URL && SUPABASE_PUBLISHABLE_KEY) {
  // Use @supabase/ssr's createBrowserClient for proper cookie handling.
  // This ensures auth tokens are stored in cookies AND localStorage,
  // keeping server-side and client-side auth in sync.
  //
  // IMPORTANT: This fixes the 2-minute auth failure issue where:
  // - Browser client used localStorage (worked fine)
  // - Server/middleware used cookies (failed after cookie expired)
  // - The old customStorage adapter actively deleted cookies, breaking server auth
  //
  // Now both client and server use the same cookie-based session.
  supabaseClient = createBrowserClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY, {
    auth: {
      // Enable automatic session refresh
      autoRefreshToken: true,
      // Persist auth session
      persistSession: true,
      // Detect session in URL (for OAuth flows)
      detectSessionInUrl: true,
      // Flow type for PKCE
      flowType: 'pkce',
      // IMPORTANT: Use the same storage key as the old client for backward compatibility
      // This ensures existing sessions in localStorage are recognized
      storageKey: 'supabase.auth.token',
    },
    realtime: {
      connect: true,
      params: { eventsPerSecond: 10 },
      retryAttempts: 6,
      timeout: 40000
    }
  });
} else if (typeof window !== 'undefined') {
  if (!hasLoggedMissingError) {
    console.error('[supabase] Public Supabase environment variables are missing. Client-side features depending on Supabase will be disabled.');
    hasLoggedMissingError = true;
  }
} else if (!hasLoggedMissingError) {
  console.warn('[supabase] Public Supabase environment variables are missing. Server-side features depending on Supabase will be disabled.');
  hasLoggedMissingError = true;
}

const missingConfigError = () =>
  new Error('Supabase client is not configured. Ensure NEXT_PUBLIC_SUPABASE_URL and NEXT_PUBLIC_SUPABASE_ANON_KEY are set.');

const createUnavailableProxy = (path: string): any => {
  const proxyTarget = () => undefined;
  return new Proxy(proxyTarget, {
    get(_target, prop) {
      if (prop === 'then') {
        return (onFulfilled?: unknown, onRejected?: unknown) =>
          Promise.reject(missingConfigError()).then(onFulfilled as any, onRejected as any);
      }
      if (prop === 'catch') {
        return (onRejected?: unknown) =>
          Promise.reject(missingConfigError()).catch(onRejected as any);
      }
      if (prop === 'finally') {
        return (onFinally?: unknown) =>
          Promise.reject(missingConfigError()).finally(onFinally as any);
      }
      return createUnavailableProxy(`${path}.${String(prop)}`);
    },
    apply(_target, _thisArg, args) {
      if (!hasLoggedMissingError) {
        console.warn(`[supabase] Attempted to call ${path} but the client is not configured.`, args);
        hasLoggedMissingError = true;
      }
      return createUnavailableProxy(`${path}()`);
    },
  });
};

const supabaseProxy = new Proxy({} as SupabaseClient<Database>, {
  get(_target, prop) {
    if (!supabaseClient) {
      return createUnavailableProxy(`supabase.${String(prop)}`);
    }
    const value = Reflect.get(supabaseClient as SupabaseClient<Database>, prop);
    return typeof value === 'function' ? value.bind(supabaseClient) : value;
  },
});

export const supabase = supabaseProxy;

export const hasSupabaseClient = () => Boolean(supabaseClient);
